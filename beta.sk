options:
    version: 1.0.1
    channel: "BETA"

on join:
    wait 5 ticks
    if {server::name} isn't set:
        set {server::name} to "My cool server!"
    if {server::%uuid of player%::tokens} isn't set:
        set {server::%uuid of player%::tokens} to 0

    if {server::alive::*} contains player:
        remove player from {server::alive::*}
    if {server::dead::*} doesn't contain player:
        add player to {server::dead::*}
    if {server::spawn} is set:
        teleport player to {server::spawn}
    else:
        loop all players:
            if loop-player has permission "ec.setspawn":
                send "&cA player has joined but the spawn was not set and they were teleported to the worldspawn!"
                send "&cPlease set one using &e`/setspawn`"
    clear the player's inventory
    clear helmet of player
    clear chestplate of player
    clear leggings of player
    clear boots of player

    if {ec::config::default-gamemode} is set:
        set player's gamemode to {ec::config::default-gamemode}


every second:
    if {ec::config::use-colored-names} is true:
        if plugin "LuckPerms" is enabled:
            if plugin "Vault" is enabled:
                loop all players:
                    if {server::alive::*} contains loop-value:
                        set display name of player to "&2%player's display name%&r"
                    else:
                        if {server::hosts::*} doesn't contain loop-value:
                            set display name of player to "&c%player's display name%&r"
                        else:
                            set display name of player to "&6%player's display name%&r"

# Main Host Panel
command /ec:
    executable by: players
    permission: ec.host.panel
    description: Open the EventCore host panel
    trigger:
        set {_panel} to a new chest inventory with 6 rows named "EventCore - Home"
        set slot 0 of {_panel} to a barrier named "&cClose" with lore "Close the panel"
        set slot 10 of {_panel} to a skeleton skull named "Dead Settings" with lore "Manage dead player defaults"
        set slot 12 of {_panel} to the player's skull named "Player Settings" with lore "Default Player Settings"
        set slot 14 of {_panel} to an ender pearl named "Warps" with lore "Warp Settings"
        set slot 16 of {_panel} to an enchanted book named "Ads" with lore "Advertisements"
        open {_panel} to player

function toggleVar(var: object) :: boolean:
    if {_var} is true:
        set {_var} to false
    else:
        set {_var} to true
    return {_var}

function openConfig(page: text = "home", player: player):
    if {_page} is "home":
        make {_player} execute command "ec"
    else if {_page} is "dead":
        set {_config} to a new chest inventory with 5 rows named "EC - Dead Players"
        set slot 0 of {_config} to a barrier named "&cBack"
        if {ec::config::allow-spectate} is true:
            set slot 10 of {_config} to lime wool named "&cDisable Spectating" with lore "&2Spectating is &a&lENABLED"
        else:
            set slot 10 of {_config} to red wool named "&cEnable Spectating" with lore "&cSpectating is &4&lDISABLED"

        if {ec::config::auto-spectate} is true:
            set slot 12 of {_config} to lime wool named "&cDisable Auto Spectating" with lore "&2Auto Spectating is &a&lENABLED"
        else:
            set slot 12 of {_config} to red wool named "&cEnable Auto Spectating" with lore "&cAuto Spectating is &4&lDISABLED"

        if {ec::config::default-gamemode} is survival:
            set slot 14 of {_config} to grass block named "&2Current:&e Survival" with lore "&2Default Gamemode is &eSurvival!"
        else if {ec::config::default-gamemode} is adventure:
            set slot 14 of {_config} to grass block named "&2Current:&e Adventure" with lore "&2Default Gamemode is &eAdventure!"
        else if {ec::config::default-gamemode} is spectator:
            set slot 14 of {_config} to grass block named "&2Current:&e Spectator" with lore "&2Default Gamemode is &eSpectator!"
        else if {ec::config::default-gamemode} is creative:
            set slot 14 of {_config} to grass block named "&2Current:&e Creative" with lore "&2Default Gamemode is &eCreative!"
        else:
            set slot 14 of {_config} to grass block named "&2Current:&e Survival" with lore "&2Default Gamemode is &eSurvival!"
        open {_config} to {_player}

    else if {_page} is "player-manage":
        set {_config} to a new chest inventory with 5 rows named "EC - Player Defaults"
        set slot 0 of {_config} to a barrier named "&cBack"
        if {ec::config::use-colored-names} is true:
            set slot 10 of {_config} to lime wool named "&cDisable Colored Names" with lore "&2Colored names are &a&lENABLED"
        else:
            set slot 10 of {_config} to red wool named "&cEnable Colored Names" with lore "&cColored names are &4&lDISABLED"
        open {_config} to {_player}

    else if {_page} is "warps":
        set {_config} to a new chest inventory with 5 rows named "EC - Warps"
        set slot 0 of {_config} to a barrier named "&cBack"
        set slot 10 of {_config} to a lime wool named "&2Create a Warp"
        set slot 13 of {_config} to a yellow wool named "&6List Warps"
        set slot 16 of {_config} to a red wool named "&cDelete a Warp"
        open {_config} to {_player}
    else if {_page} is "ads":
        set {_config} to a new chest inventory with 5 rows named "EC - Advertisements"
        set slot 0 of {_config} to a barrier named "&cBack"
        set slot 10 of {_config} to a lime wool named "&2Create an ad"
        set slot 12 of {_config} to a yellow wool named "&6List ads"
        set slot 14 of {_config} to a red wool named "&cDelete an ad"
        set slot 16 of {_config} to a green wool named "&2Set &cYoutube&2 ad"
        set slot 18 of {_config} to a green wool named "&2Set &bDiscord&2 ad"
        open {_config} to {_player}

on inventory click:
    if name of event-inventory is "EventCore - Home":
        cancel event
        if event-slot is 0:
            close the player's inventory
        else if event-slot is 10:
            openConfig("dead", player)
        else if event-slot is 12:
            openConfig("player-manage", player)
        else if event-slot is 14:
            openConfig("warps", player)
        else if event-slot is 16:
            openConfig("ads", player)
    else if name of event-inventory is "EC - Dead Players":
        cancel event
        if event-slot is 0:
            openConfig("home", player)
        else if event-slot is 10:
            set {_new} to toggleVar({ec::config::allow-spectate})
            set {ec::config::allow-spectate} to {_new}
            openConfig("dead", player)
        else if event-slot is 12:
            set {_new} to toggleVar({ec::config::auto-spectate})
            set {ec::config::auto-spectate} to {_new}                   
            openConfig("dead", player)
        else if event-slot is 14:
            if {ec::config::default-gamemode} is survival:
                set {ec::config::default-gamemode} to adventure
            else if {ec::config::default-gamemode} is adventure:
                set {ec::config::default-gamemode} to creative
            else if {ec::config::default-gamemode} is creative:
                set {ec::config::default-gamemode} to spectator
            else if {ec::config::default-gamemode} is spectator:
                set {ec::config::default-gamemode} to survival
            else:
                set {ec::config::default-gamemode} to adventure
            openConfig("dead", player)
    else if name of event-inventory is "EC - Player Defaults":
        cancel event
        if event-slot is 0:
            openConfig("home", player)
        else if event-slot is 10:
            set {_new} to toggleVar({ec::config::use-colored-names})
            set {ec::config::use-colored-names} to {_new}
            openConfig("player-manage", player)
    else if name of event-inventory is "EC - Warps":
        cancel event
        if event-slot is 0:
            openConfig("home", player)
        else if event-slot is 10:
            close the player's inventory
            send "&2Type the name of the warp to create:"
            set {server::%uuid of player%::awaiting::warp::create} to true
    else if name of event-inventory is "EC - Advertisements":
        cancel event
        if event-slot is 0:
            openConfig("home", player)
        else if event-slot is 10:
            close the player's inventory
            make player execute command "createad"
        else if event-slot is 12:
            close the player's inventory
            make player execute command "listads"
        else if event-slot is 14:
            close the player's inventory
            set {server::%uuid of player%::awaiting::ad::delete} to true
            send "&2Type the name of the ad to delete:"
        else if event-slot is 16:
            close the player's inventory
            set {server::%uuid of player%::awaiting::ad::youtube} to true
            send "&2Type your &cyoutube&2 link:"
        else if event-slot is 18:
            close the player's inventory
            set {server::%uuid of player%::awaiting::ad::discord} to true
            send "&2Type your &bdiscord&2 link:"


# Warps / TP
command /setwarp <text>:
    executable by: players
    description: Create a Warp
    permission: ec.host.warp.create
    usage: /setwarp <warp_name>
    aliases: createwarp, makewarp, addwarp
    trigger:
        set {_name} to arg-1
        set {_loc} to the player's location

        if {server::warps::%{_name}%} is set:
            send "&cThis warp already exists!" to player
            stop

        set {server::warps::%{_name}%} to {_name}
        set {server::warps::%{_name}%::loc} to {_loc}
        send "&2Created warp &e%{server::warps::%{_name}%}%&2 at location: &e%{server::warps::%{_name}%::loc}%"

command /delwarp <text>:
    description: Delete a Warp
    permission: ec.host.warp.delete
    usage: /delwarp <warp_name>
    aliases: deletewarp, unsetwarp, removewarp, remwarp
    trigger:
        set {_name} to arg-1

        if {server::warps::%{_name}%} isn't set:
            send "&cThis warp doesn't exist!" to player
            stop

        delete {server::warps::%{_name}%}
        send "&2Warp &e%{_name}%&2 Successfully deleted!"

command /listwarps:
    description: List all available warps
    permission: ec.host.warp.list
    usage: warplist, listwarp, allwarps, allwarp
    trigger:
        loop {server::warps::*}:
            send "- &e%loop-index%"

command /tphere <text>:
    executable by: players
    description: Tp a player/all/dead/alive players to you
    permission: ec.host.tp.here
    usage: /tphere <player|all|dead|alive>
    trigger:
        set {_arg} to arg-1
        if {_arg} is "all":
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All players teleported to you!" to player
        else if {_arg} is "dead":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All dead players teleported to you!" to player
        else if {_arg} is "alive":
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All alive players teleported to you!" to player
        else:
            set {_arg} to {_arg} parsed as player
            if {_arg} isn't set:
                send "&cInvalid player/player is not online!" to player
            else:
                teleport {_arg} to player
                send "&e%{_arg}%&2 has been teleported to you!" to player
command /tpall [<text>]:
    executable by: players
    description: Teleported all players to you or a warp
    usage: /tpall [warp_name]
    permission: ec.host.tp.all
    trigger:
        set {_arg} to arg-1
        if {_arg} isn't set:
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All players teleported to you!" to player
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} isn't set:
                send "&cThis warp does not exist!" to player
                stop
            else:
                loop all players:
                    if {server::hosts::*} doesn't contain uuid of loop-value:
                        teleport loop-value to {_warp}
            send "&2All players teleported to &e!%{_warp}%!" to player

command /tpalive [<text>]:
    executable by: players
    description: Teleport all alive players to you or a warp
    permission: ec.host.tp.alive
    trigger:
        set {_arg} to arg-1
        if {_arg} is not set:
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player

            send "&2All alive players teleported to you!"
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} is not set:
                send "&cThis warp does not exist!"
                stop
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to {_warp}
            send "&2All alive players teleported to &e%{_arg}%!"

command /tpdead [<text>]:
    executable by: players
    description: Teleport all dead players to you or a warp
    permission: ec.host.tp.dead
    trigger:
        set {_arg} to arg-1
        if {_arg} is not set:
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All dead players teleported to you!"
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} is not set:
                send "&cThis warp does not exist!"
                stop
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to {_warp}
            send "&2All dead players teleported to &e%{_arg}%!"

# Host management
command /addhost <player>:
    description: Set a player to be a host (does not give more permissions!)
    permission: ec.host.addhost
    aliases: createhost, makehost, sethost
    trigger:
        set {_arg} to arg-1
        if {server::hosts::*} contains uuid of {_arg}:
            send "&cThis player is already a host!"
            stop
        add uuid of {_arg} to {server::hosts::*} 
        send "&2Made &e%{_arg}%&2 a host!"

command /remhost <offline player>:
    description: Remove a player from the host list (does not remove permissions!)
    permission: ec.host.remhost
    aliases: removehost, deletehost, unsethost
    trigger:
        set {_arg} to arg-1
        if {server::hosts::*} doesn't contain uuid of {_arg}:
            send "&cThis player is not a host!"
            stop
        remove uuid of {_arg} from {server::hosts::*} 
        send "&2Remove &e%{_arg}%&2 from host list!"

# Server management
command /setserver <text>:
    description: Set the server name
    permission: ec.server.setserver
    usage: /setserver <name>
    trigger:
        set {_name} to arg-1
        set {server::name} to {_name}
        send "&2Set server name to &e%{server::name}%!"

command /setevent <text>:
    description: Set the next event
    permission: ec.server.event.setevent
    usage: /setevent <name>
    trigger:
        set {_name} to arg-1
        set {server::event} to {_name}
        send "&2Set event to &e%{server::event}%!"

command /setspawn:
    description: Set the server's spawnpoint
    permission: ec.setspawn
    trigger:
        set {server::spawn} to the player's position
        loop all players:
            if loop-value has permission "ec.setspawn":
                send "&e%player%&2 has set the spawnpoint to &e%{server::spawn}%"

# Timers and Cooldowns
command /timer [<text>]:
    description: Start or cancel a countdown timer
    permission: ec.host.timer
    usage: /timer (cancel|<seconds>)
    trigger:
        if arg-1 is "cancel":
            if {server::timer} > 0:
                set {server::timer} to 0
                send "&2Timer cancelled!"
            else:
                send "&cNo timer running!"
            stop

        set {_time} to arg-1 parsed as integer
        if {_time} <= 0:
            send "&cTime must be greater than 0!"
            stop
        if {server::timer} > 0:
            send "&cA timer is already running!"
            stop
        set {server::timer} to {_time}
        send "&2Timer started for %{_time}% seconds!"

        while {server::timer} > 0:
            broadcast "&e%{server::timer}% seconds left!"
            wait 1 second
            remove 1 from {server::timer}

        # This will always run after the timer reaches 0
        broadcast "&2Times up!"

command /eventcooldown <number>:
    description: Start the event cooldown
    permission: ec.host.event.cooldown
    usage: /eventcooldown <minutes>
    trigger:
        set {_arg} to arg-1
        if {_arg} <= 0:
            send "&cTime must be greater than 0!"
            stop
        if {server::event::cooldown} > 0:
            send "&cA cooldown is already running!"
            stop
        set {server::event::cooldown} to {_arg} * 60
        if {_arg} > 1:
            broadcast "&eEvent starts in &c%({server::event::cooldown} / 60)% &eminutes!"
        while {server::event::cooldown} > 0:
            if {server::event::cooldown} is 0:
                stop loop
            if {server::event::cooldown} >= 300:
                if mod({server::event::cooldown},300) = 0:
                    broadcast "&e%{server::event}% starts in &c%({server::event::cooldown} / 60)% &eminutes!"

            # 1 minute
            if {server::event::cooldown} = 60:
                broadcast "&e%{server::event}% starts in &c1 minute!"

            # 30 seconds
            if {server::event::cooldown} = 30:
                broadcast "&e%{server::event}% starts in &c30 seconds!"

            # 10 seconds
            if {server::event::cooldown} <= 10:
                broadcast "&e%{server::event}% starts in &c%{server::event::cooldown}% &eseconds!"

            wait 1 second
            remove 1 from {server::event::cooldown}
        broadcast "&a%{server::event}% is starting!!"


# Kits
command /createkit <text>:
    executable by: players
    description: Create a kit
    permission: ec.host.kits.create
    usage: /createkit <name>
    aliases: setkit, makekit, addkit
    trigger:
        set {_kit} to lowercase arg-1

        if {server::kits::%{_kit}%::exists} is true:
            send "&cThis kit already exists!"
            stop
        set {server::kits::%{_kit}%::exists} to true

        set {server::kits::%{_kit}%::armor::helmet} to player's helmet
        set {server::kits::%{_kit}%::armor::chestplate} to player's chestplate
        set {server::kits::%{_kit}%::armor::leggings} to player's leggings
        set {server::kits::%{_kit}%::armor::boots} to player's boots

        set {_slot} to 0 
        loop 36 times:
            set {server::kits::%{_kit}%::inv::%{_slot}%} to slot {_slot} of player's inventory
            add 1 to {_slot}

        send "&aCreated kit: &e%{_kit}%"

command /givekit <text> <text>:
    description: Give a kit to a player/group of players
    permission: ec.kits.givekit
    aliases: grantkit
    usage: /givekit <player|all|alive|dead> <kit>
    trigger:
        set {_arg} to arg-1
        set {_kit} to lowercase arg-2

        if {server::kits::%{_kit}%::exists} is not true:
            send "&cThis kit does not exist!"
            stop

        if {_arg} is "all":
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all players!"
            stop

        if {_arg} is "alive":
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all alive players!"
            stop

        if {_arg} is "dead":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all dead players!"
            stop

        set {_p} to {_arg} parsed as player
        if {_p} is not set:
            send "&cInvalid player/player is not online!"
            stop

        giveKit({_p}, {_kit})
        send "&2Gave kit &e%{_kit}%&2 to &e%{_p}%!"

function giveKit(p: player, kit: text):
    clear {_p}'s inventory

    set {_p}'s helmet to {server::kits::%{_kit}%::armor::helmet}
    set {_p}'s chestplate to {server::kits::%{_kit}%::armor::chestplate}
    set {_p}'s leggings to {server::kits::%{_kit}%::armor::leggings}
    set {_p}'s boots to {server::kits::%{_kit}%::armor::boots}
    set {_slot} to 0
    loop 36 times:
        set slot {_slot} of {_p}'s inventory to {server::kits::%{_kit}%::inv::%{_slot}%}
        add 1 to {_slot}

command /deletekit <text>:
    executable by: players
    description: Delete a kit
    permission: ec.host.kits.delete
    usage: /deletekit <name>
    aliases: delkit, removekit
    trigger:
        set {_kit} to lowercase arg-1
        if {server::kits::%{_kit}%::exists} is not true:
            send "&cThis kit does not exist!"
            stop
        set {server::kits::%{_kit}%::exists} to false
        delete {server::kits::%{_kit}%}
        send "&2Deleted kit: &e%{_kit}%"

command /invsee <player>:
    executable by: players
    description: View/Edit a player's inventory
    permission: ec.invsee
    trigger:
        set {_player} to arg-1
        set {_inv} to {_player}'s inventory
        open {_inv} to player

command /stats [<player>]:
    description: View a player's stats
    trigger:
        set {_p} to arg-1
        if {_p} is not set: 
            set {_p} to player
        send "&eStats for %{_p}%:"
        send "&2Tokens: &e%{server::%uuid of {_p}%::tokens}%"
        send "&2Wins: &e%{server::%uuid of {_p}%::wins}%"
        send "&2Kills: &e%{server::%uuid of {_p}%::kills}%"
        send "&2Deaths: &e%{server::%uuid of {_p}%::deaths}%"


on death of player:
    set {server::deathTime::%uuid of victim%} to now
    force victim to respawn
    if attacker is a player:
        add 1 to {server::%uuid of attacker%::kills}
    add 1 to {server::%uuid of victim%::deaths}
    if {server::alive::*} contains victim:
        remove victim from {server::alive::*}
    if {server::dead::*} doesn't contain victim:
        add victim to {server::dead::*}

on respawn:
    if {ec::config::auto-spectate} isn't true:
        if {server::spawn} is set:
            teleport player to {server::spawn}
        else:
            teleport player to spawn
    else:
        make player execute command "spectate"


# Gamemode
command /gmc [<player>]:
    description: Switch to creative mode
    permission: ec.host.gamemode.creative
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to creative
            stop
        set the player's gamemode to creative

command /gms [<player>]:
    description: Switch to survival mode
    permission: ec.host.gamemode.survival
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to survival
            stop
        set the player's gamemode to survival

command /gmsp [<player>]:
    description: Switch to spectator mode
    permission: ec.host.gamemode.spectator
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to spectator
            stop
        set the player's gamemode to spectator
    
command /gma [<player>]:
    description: Switch to adventure mode
    permission: ec.host.gamemode.adventure
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to adventure
            stop
        set the player's gamemode to adventure

# Wins and Tokens
command /addwin <player>:
    description: Give a player a win
    permission: ec.host.wins.add
    aliases: givewin, grantwin
    trigger:
        set {_p} to arg-1

        add 1 to {server::%uuid of {_p}%::wins}
        broadcast "&e%{_p}%&2 has received a win! They now have &e%{server::%uuid of {_p}%::wins}% wins!"

command /addtoken <player>:
    description: Give a player a token
    permission: ec.host.tokens.add
    aliases: givetoken, granttoken, grantoken
    trigger:
        set {_p} to arg-1

        add 1 to {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&2 has received a revive token! They now have &e%{server::%uuid of {_p}%::tokens}% revive tokens!"

command /removewin <player>:
    description: Remove a win from a player
    permission: ec.host.wins.remove
    aliases: givewin, grantwin
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::wins} <= 0:
            send "&cThey don't have any wins!"
            stop
        remove 1 from {server::%uuid of {_p}%::wins}
        broadcast "&e%{_p}%&c has lost a win! They now have &e%{server::%uuid of {_p}%::wins}% wins!"

command /removetoken <player>:
    description: Remove a token from a player
    permission: ec.host.tokens.remove
    aliases: taketoken, remtoken, retractoken
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::tokens} <= 0:
            send "&cThey don't have any tokens!"
            stop
        remove 1 from {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&c has lost a revive token! They now have &e%{server::%uuid of {_p}%::tokens}% revive tokens!"

command /usetoken:
    description: Use a revive token
    cooldown: 1 minute
    cooldown message: You can request a revive in %remaining time%!
    trigger:
        if {server::%uuid of player%::requestingRevive} is true:
            send "&cYou are already requesting a revive!"
            stop
        if {server::%uuid of player%::tokens} < 1:
            send "&cYou don't have any tokens!"
            stop
        
        loop all players:
            if loop-value has permission "ec.host.tokens.accept":
                send "&e%player%&2 is requesting to use a revive token!"
                send "&e/accepttoken %player%&2 - Accept their token"
                send "&e/denytoken %player%&2 - Deny their token"
        set {server::%uuid of player%::requestingRevive} to true

command /accepttoken <player>:
    description: Accept a player's revive token
    permission: ec.host.tokens.accept
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::requestingRevive} isn't true:
            send "&cThis player isn't requesting a revive!"
            stop
        set {server::%uuid of {_p}%::requestingRevive} to false
        remove 1 from {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&2 has used a revive token!"
        send "&2You accepted %{_p}%'s token!" to player
        send "&2Your token has been accepted!" to {_p}

command /denytoken <player>:
    description: Deny a player's revive token
    permission: ec.host.tokens.deny
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::requestingRevive} isn't true:
            send "&cThis player isn't requesting a revive!"
            stop
        set {server::%uuid of {_p}%::requestingRevive} to false
        send "&cYou denied %{_p}%'s token!" to player
        send "&cYour token has been denied!" to {_p}

command /pvp:
    description: Toggle PvP in the current region
    permission: ec.host.worldguard.pvp
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {_reg} is not set:
            send "&cNo region detected."
            stop

        if {server::region::%{_reg}%::pvp} is true:
            set {server::region::%{_reg}%::pvp} to false
            make player execute command "region flag %{_reg}% -w %{_world}% pvp deny"
            broadcast "&câš” PvP disabled &7in region &e%{_reg}% &7(%{_world}%)"
        else:
            set {server::region::%{_reg}%::pvp} to true
            make player execute command "region flag %{_reg}% -w %{_world}% pvp allow"
            broadcast "&aâš” PvP enabled &7in region &e%{_reg}% &7(%{_world}%)"


# --- BLOCK BREAK ---
command /break:
    description: Toggle block breaking in the region
    permission: ec.host.worldguard.break
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::break} is true:
            set {server::region::%{_reg}%::break} to false
            make player execute command "region flag %{_reg}% -w %{_world}% block-break deny"
            broadcast "&cðŸ§± Block breaking disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::break} to true
            make player execute command "region flag %{_reg}% -w %{_world}% block-break allow"
            broadcast "&aðŸ§± Block breaking enabled &7in &e%{_reg}%"


# --- BLOCK PLACE ---
command /place:
    description: Toggle block placing in the region
    permission: ec.host.worldguard.place
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::place} is true:
            set {server::region::%{_reg}%::place} to false
            make player execute command "region flag %{_reg}% -w %{_world}% block-place deny"
            broadcast "&cðŸ“¦ Block placing disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::place} to true
            make player execute command "region flag %{_reg}% -w %{_world}% block-place allow"
            broadcast "&aðŸ“¦ Block placing enabled &7in &e%{_reg}%"


# --- WATER FLOW ---
command /flow:
    description: Toggle water & lava flow in the region
    permission: ec.host.worldguard.flow
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::flow} is true:
            set {server::region::%{_reg}%::flow} to false
            make player execute command "region flag %{_reg}% -w %{_world}% water-flow deny"
            make player execute command "region flag %{_reg}% -w %{_world}% lava-flow deny"
            broadcast "&cðŸŒŠ Fluid flow disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::flow} to true
            make player execute command "region flag %{_reg}% -w %{_world}% water-flow allow"
            make player execute command "region flag %{_reg}% -w %{_world}% lava-flow allow"
            broadcast "&aðŸŒŠ Fluid flow enabled &7in &e%{_reg}%"

# --- FALL DAMAGE ---
command /fall:
    description: Toggle fall damage in the region
    permission: ec.host.worldguard.fall
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {_reg} is not set:
            send "&cNo region detected."
            stop

        if {server::region::%{_reg}%::fall} is true:
            set {server::region::%{_reg}%::fall} to false
            make player execute command "region flag %{_reg}% -w %{_world}% fall-damage deny"
            broadcast "&cðŸª‚ Fall damage disabled &7in region &e%{_reg}% &7(%{_world}%)"
        else:
            set {server::region::%{_reg}%::fall} to true
            make player execute command "region flag %{_reg}% -w %{_world}% fall-damage allow"
            broadcast "&aðŸª‚ Fall damage enabled &7in region &e%{_reg}% &7(%{_world}%)"
            
# --- PORTAL USE ---
command /portals:
    description: Toggle portal use
    permission: ec.host.toggleportals
    trigger:
        if {ec::config::portals-allowed} is true:
            set {ec::config::portals-allowed} to false
            broadcast "&cPortals have been disabled!"
        else:
            set {ec::config::portals-allowed} to true
            broadcast "&aPortals have been enabled!"


on portal enter:
    if {ec::config::portals-allowed} isn't true:
        if event-entity is a player:
            cancel event
# Scoreboard
on join:
    if {server::hosts::*} doesn't contain player:
        set {_board} to player's scoreboard
        set line 1 of {_board} to "Event:"
        set score of line 1 of {_board} to {server::event}

        set line 2 of {_board} to "Wins:"
        set score of line 2 of {_board} to "&e%{server::%uuid of player%::wins}%"

        set line 3 of {_board} to "Tokens:"
        set score of line 3 of {_board} to "&e%{server::%uuid of player%::tokens}%"
        set player's scoreboard to {_board}
        set title of player's scoreboard to "&cDeath &eEvents"
    else:
        set {_board} to player's scoreboard
        set line 1 of {_board} to "Event:"
        set score of line 1 of {_board} to {server::event}

        set line 2 of {_board} to "Alive:"
        set score of line 2 of {_board} to "&e%size of {server::alive::*}%"

        set line 3 of {_board} to "Dead:"
        set score of line 3 of {_board} to "&e%size of {server::dead::*}%"

        set line 4 of {_board} to "Total:"
        set score of line 4 of {_board} to "&e%size of all players%"

        set player's scoreboard to {_board}
        set title of player's scoreboard to "&cDeath &eEvents &7- Host"

every second:
    loop all players:
        if {server::hosts::*} doesn't contain loop-player:
            set {_board} to loop-player's scoreboard
            set line 1 of {_board} to "Event:"
            set score of line 1 of {_board} to {server::event}

            set line 2 of {_board} to "Wins:"
            set score of line 2 of {_board} to "&e%{server::%uuid of loop-player%::wins}%"

            set line 3 of {_board} to "Tokens:"
            set score of line 3 of {_board} to "&e%{server::%uuid of loop-player%::tokens}%"
            set loop-player's scoreboard to {_board}
            set title of loop-player's scoreboard to "&cDeath &eEvents"
        else:
            set {_board} to loop-player's scoreboard
            set line 1 of {_board} to "Event:"
            set score of line 1 of {_board} to {server::event}

            set line 2 of {_board} to "Alive:"
            set score of line 2 of {_board} to "&e%size of {server::alive::*}%"

            set line 3 of {_board} to "Dead:"
            set score of line 3 of {_board} to "&e%size of {server::dead::*}%"

            set line 4 of {_board} to "Total:"
            set score of line 4 of {_board} to "&e%size of all players%"

            set loop-player's scoreboard to {_board}
            set title of loop-player's scoreboard to "&cDeath &eEvents &7- Host"


on enter of region:
    set {_rg} to "%region%"
    set {_regions::*} to split {_rg} at " "
    set {_region} to {_regions::1}
    set {server::%uuid of player%::region} to {_region}
    set {server::%uuid of player%::world} to name of player's world

command /whereami:
    permission: ec.whereami
    trigger:
        send "&aRegion: &e%{server::%uuid of player%::region}%"
        send "&aWorld: &e%{server::%uuid of player%::world}%"




# Revives
function revivePlayer(p: player, user: player):
    if {server::dead::*} contains {_p}:
        remove {_p} from {server::dead::*}
    if {server::alive::*} doesn't contain {_p}:
        add {_p} to {server::alive::*}

    clear {_p}'s inventory
    set {_p}'s gamemode to survival
    teleport {_p} to {_user}

    send "&aâ˜  You have been revived!" to {_p}

command /revive <text> [<number>]:
    description: Revive players
    permission: ec.host.revive
    usage: /revive (all|last|<player>) [seconds]
    aliases: rev, res
    trigger:
        set {_arg} to arg-1
        set {_arg2} to arg-2

        # --- REVIVE ALL ---
        if {_arg} is "all":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    revivePlayer(loop-value, player)
            broadcast "&aâœ¨ All players have been revived!"
            stop

        # --- REVIVE LAST ---
        if {_arg} is "last":
            set {_secs} to {_arg2} parsed as number
            if {_secs} is not set:
                send "&cYou must specify seconds. &7(/revive last <seconds>)"
                stop
            if {_secs} <= 0:
                send "&cYou must specify seconds. &7(/revive last <seconds>)"
                stop

            set {_count} to 0
            loop {server::dead::*}:
                set {_t} to {server::deathTime::%uuid of loop-value%}
                if {_t} is set:
                    if difference between {_t} and now is less than or equal to {_secs} seconds:
                        revivePlayer(loop-value, player)
                        add 1 to {_count}

            if {_count} > 0:
                broadcast "&aâœ¨ Revived %{_count}% player(s) who died in the last %{_secs}%s!"
            else:
                send "&cNo players died in the last %{_secs}% seconds."
            stop

        # --- REVIVE PLAYER ---
        set {_p} to {_arg} parsed as player
        if {_p} is not set:
            send "&cInvalid player!"
            stop

        if {server::dead::*} doesn't contain {_p}:
            send "&cThat player is not dead!"
            stop

        revivePlayer({_p}, player)
        broadcast "&aâœ¨ %{_p}% has been revived!"

# Mute chat
command /mutechat:
    description: Mute the chat so only hosts can talk
    permission: ec.host.chat.mute
    trigger:
        if {server::chat::muted} is true:
            send "&cChat is already muted!" to player
            stop
        set {server::chat::muted} to true
        broadcast "&cChat has been muted! Only hosts can talk now."

# Unmute chat
command /unmutechat:
    description: Unmute the chat
    permission: ec.host.chat.mute
    trigger:
        if {server::chat::muted} is false:
            send "&cChat is not muted!" to player
            stop
        set {server::chat::muted} to false
        broadcast "&aChat has been unmuted! Everyone can talk now."

# Block messages from non-hosts when chat is muted
on chat:
    if {server::chat::muted} is true:
        if {server::hosts::*} does not contain uuid of player:
            cancel event
            send "&cChat is currently muted! Only hosts can speak."


# Other User Commands
command /spectate:
    description: Toggle Spectator mode
    trigger:
        if {ec::config::allow-spectate} is true:
            if player's gamemode isn't spectator:
                set player's gamemode to spectator
            else:
                if {ec::config::default-gamemode} is set:
                    set player's gamemode to {ec::config::default-gamemode}
                else:
                    set player's gamemode to survival
                if {server::spawn} is set:
                    teleport player to {server::spawn}
                else:
                    teleport player to spawn
        else:
            send "&cSpectating is disabled!"


# Help Menu
command /echelp:
    trigger:
        send "&c&l=== EventCore Help ==="
        
        # Host Panel
        if player has permission "ec.host.panel":
            send "&e/ec &7- Open the host panel"
        
        # Warps / TP
        if player has permission "ec.host.warp.create":
            send "&e/setwarp <name> &7- Create a warp"
        if player has permission "ec.host.warp.delete":
            send "&e/delwarp <name> &7- Delete a warp"
        if player has permission "ec.host.warp.list":
            send "&e/listwarps &7- List all warps"
        if player has permission "ec.host.tp.here":
            send "&e/tphere <player|all|alive|dead> &7- Teleport players to you"
        if player has permission "ec.host.tp.all":
            send "&e/tpall [warp] &7- Teleport all players to you or a warp"
        if player has permission "ec.host.tp.alive":
            send "&e/tpalive [warp] &7- Teleport alive players"
        if player has permission "ec.host.tp.dead":
            send "&e/tpdead [warp] &7- Teleport dead players"
        
        # Hosts
        if player has permission "ec.host.addhost":
            send "&e/addhost <player> &7- Make a player a host"
        if player has permission "ec.host.remhost":
            send "&e/remhost <player> &7- Remove a host"
        
        # Server
        if player has permission "ec.server.setserver":
            send "&e/setserver <name> &7- Set the server name"
        if player has permission "ec.server.event.setevent":
            send "&e/setevent <name> &7- Set the next event"
        if player has permission "ec.setspawn":
            send "&e/setspawn &7- Set the server spawnpoint"
        
        # Timers / Cooldowns
        if player has permission "ec.host.timer":
            send "&e/timer <seconds> &7- Start a countdown timer"
        if player has permission "ec.host.event.cooldown":
            send "&e/eventcooldown <minutes> &7- Start the event cooldown"
        
        # Kits
        if player has permission "ec.host.kits.create":
            send "&e/createkit <name> &7- Create a kit"
        if player has permission "ec.kits.givekit":
            send "&e/givekit <player|all|alive|dead> <kit> &7- Give a kit"
        if player has permission "ec.host.kits.delete":
            send "&e/deletekit <name> &7- Delete a kit"
        
        # Inventory
        if player has permission "ec.invsee":
            send "&e/invsee <player> &7- View/Edit a player's inventory"
        
        # Stats
        send "&e/stats [player] &7- View player's stats"
        
        # Gamemodes
        if player has permission "ec.host.gamemode.creative":
            send "&e/gmc [player] &7- Switch to Creative"
        if player has permission "ec.host.gamemode.survival":
            send "&e/gms [player] &7- Switch to Survival"
        if player has permission "ec.host.gamemode.spectator":
            send "&e/gmsp [player] &7- Switch to Spectator"
        if player has permission "ec.host.gamemode.adventure":
            send "&e/gma [player] &7- Switch to Adventure"
        
        # Wins & Tokens
        if player has permission "ec.host.wins.add":
            send "&e/addwin <player> &7- Give a player a win"
        if player has permission "ec.host.wins.remove":
            send "&e/removewin <player> &7- Remove a win from a player"
        if player has permission "ec.host.tokens.add":
            send "&e/addtoken <player> &7- Give a player a token"
        if player has permission "ec.host.tokens.remove":
            send "&e/removetoken <player> &7- Remove a token from a player"
        send "&e/usetoken &7- Use a revive token"
        if player has permission "ec.host.tokens.accept":
            send "&e/accepttoken <player> &7- Accept a token request"
        if player has permission "ec.host.tokens.deny":
            send "&e/denytoken <player> &7- Deny a token request"
        
        # Revives
        if player has permission "ec.host.revive":
            send "&e/revive <all|last|player> [seconds] &7- Revive players"
        
        # Chat
        if player has permission "ec.host.chat.mute":
            send "&e/mutechat &7- Mute chat"
            send "&e/unmutechat &7- Unmute chat"
        
        # PvP / WG
        if player has permission "ec.host.worldguard.pvp":
            send "&e/pvp &7- Toggle PvP in region"
        if player has permission "ec.host.worldguard.break":
            send "&e/break &7- Toggle block breaking in region"
        if player has permission "ec.host.worldguard.place":
            send "&e/place &7- Toggle block placing in region"
        if player has permission "ec.host.worldguard.flow":
            send "&e/flow &7- Toggle water/lava flow in region"
        if player has permission "ec.host.worldguard.fall":
            send "&e/fall &7- Toggle fall damage in region"
        
        # Misc
        if player has permission "ec.whereami":
            send "&e/whereami &7- Show current region and world"


on command:
    if command is "ec help":
        make player execute command "echelp"
    else if command is "help ec":
        make player execute command "echelp"
    else if command is "help":
        wait 5 ticks
        make player execute command "echelp"



# Ads
command /createad:
    description: Create an ad
    permission: ec.host.ad.create
    trigger:
        set {server::%uuid of player%::awating::ad::create::name} to true
        send "&2Type an ID or Name for the ad"

command /deletead <text>:
    description: Delete an ad
    permission: ec.host.ad.delete
    trigger:
        set {_ad} to arg-1
        if {server::ads::%{_ad}%} isn't set:
            send "&cThis ad doesn't exist!" 
        else:
            delete {server::ads::%{_ad}%::*}
            delete {server::ads::%{_ad}%}
            send "&2Successfuly delete the ad!"

command /listads:
    description: View a list of ads
    permission: ec.host.ads.view
    trigger:
        if size of {server::ads::*} < 1:
            send "&cNo ads set!"
            send "&2Create one with &e`/createad`"
            stop
        loop {server::ads::*}:
            send "&2- &e%loop-index%"

command /editad <text> <number>:
    description: Edit an ad's line
    permission: ec.host.ad.edit
    trigger:
        set {_ad} to arg-1
        set {_line} to arg-2
        set {server::%uuid of player%::awating::ad::edit::line} to "%{_ad}%:%{_line}%"
        send "&2Type the line of the ad"
        
on chat:
    # Creating an ad
    if {server::%uuid of player%::awating::ad::create::name} is true:
        cancel event
        set {_adName} to message
        set {server::ads::%{_adName}%} to message
        send "&2Created ad named &e%{_adName}%&2!"
        send "&2You can edit it by typing &e/editad %{_adName}% <line_number>"
        set {server::%uuid of player%::awating::ad::create::name} to false
        delete {server::%uuid of player%::awating::ad::create::name}

    # Editing an ad
    else if {server::%uuid of player%::awating::ad::edit::line} is set:
        cancel event
        set {_words::*} to {server::%uuid of player%::awating::ad::edit::line} split at ":"
        set {_ad} to {_words::1}
        set {_line} to {_words::2}
        if {server::ads::%{_ad}%} isn't set:
            send "&cAd &e%{_ad}% &cdoesn't exist! Use &e/createad <ad> &cto make one."
        else:
            cancel event
            set {server::ads::%{_ad}%::line::%{_line}%} to message
            send "&2Ad successfully edited! &6Updated Ad:"
            loop {server::ads::%{_ad}%::line::*}:
                send formatted loop-value
        set {server::%uuid of player%::awating::ad::edit::line} to false
        delete {server::%uuid of player%::awating::ad::edit::line}

    # Deleting an ad
    else if {server::%uuid of player%::awaiting::ad::delete} is true:
        cancel event
        make player execute command "deletead %message%"
        send "&2Attempted to delete ad named &e%message%&2!"
        set {server::%uuid of player%::awaiting::ad::delete} to false
        delete {server::%uuid of player%::awaiting::ad::delete}

    # Updating YouTube link
    else if {server::%uuid of player%::awaiting::ad::youtube} is true:
        cancel event
        set {server::youtube::link} to message
        send "&2YouTube link updated to &e%message%&2!"
        set {server::%uuid of player%::awaiting::ad::youtube} to false
        delete {server::%uuid of player%::awaiting::ad::youtube}

    # Updating Discord link
    else if {server::%uuid of player%::awaiting::ad::discord} is true:
        cancel event
        set {server::discord::link} to message
        send "&2Discord link updated to &e%message%&2!"
        set {server::%uuid of player%::awaiting::ad::discord} to false
        delete {server::%uuid of player%::awaiting::ad::discord}
    else if {server::%uuid of player%::awaiting::warp::create} is true:
        cancel event
        set {_warpName} to message
        make player execute command "setwarp %{@warpName}%"
        set {server::%uuid of player%::awaiting::warp::create} to false
        delete {server::%uuid of player%::awaiting::warp::create}
    

command /ad <text>:
    description: Advertise an ad
    permission: ec.host.ad.ad
    trigger:
        if {server::ads::%{_ad}%} isn't set:
            send "&cThis ad doesn't exist!" 
        else:
            loop {server::ads::%{_ad}%::line::*}:
                broadcast formatted loop-value


command /youtube:
    description: View the server's Youtube link
    aliases: yt
    trigger:
        if {server::youtube::link} is set:
            send formatted "<link:%{server::youtube::link}%>&6Click Here&2 to check out our youtube channel!<reset>"
        else:
            send "&cThis server hasn't setup a youtube link!"

command /discord:
    description: View the server's Discord link
    aliases: dc
    trigger:
        if {server::discord::link} is set:
            send formatted "<link:%{server::discord::link}%>&6Click Here&2 to check out our discord!<reset>"
        else:
            send "&cThis server hasn't setup a discord link!"


        

every 1 second in "world":
    if {ec::config::allow-spectate} isn't true:
        loop all players:
            if loop-player's gamemode is spectator:
                if {ec::config::default-gamemode} is set:
                    set loop-player's gamemode to {ec::config::default-gamemode}
                else:
                    set loop-player's gamemode to survival
                if {server::spawn} is set:
                    teleport loop-player to {server::spawn}
                else:
                    teleport loop-player to spawn




command /hunger:
    description: Toggle worldwide hunger
    permission: ec.host.toggle.hunger
    trigger:
        if {server::hunger} is true:
            set {server::hunger} to false
            broadcast "&c&lHunger has been disabled"
        else:
            set {server::hunger} to true
            broadcast "&a&lHunger has been enabled"

every 10 seconds:
    if {server::hunger} is false:
        execute CONSOLE command "effect give @a saturation 10 255 true"

command /smite <text>:
    description: Smite a player
    permission: ec.host.smite
    usage: /smite (<player>|all|alive|dead)
    trigger:
        set {_arg} to arg-1
        if {_arg1} is "all":
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-player:
                    strike lightning at loop-player
        else if {_arg} is "alive":
            loop {server::alive::*}:
                strike lightning at loop-player
        else if {_arg} is "dead":
            loop {server::dead::*}:
                strike lightning at loop-player
        else:
            set {_arg} to {_arg} parsed as player
            strike lightning at {_arg}


on load:
    if {ec::config::version} isn't {@version}:
        set {ec::config::version} to {@version}
    else:
        stop
    if {ec::config::channel} isn't {@channel}:
        set {ec::config::channel} to {@channel}
    loop all players:
        send "&2EventCore has been updated to %{@version}%!" to loop-player
        send "&2Be sure to type &e`/echelp`&2 to view new commands!" to loop-player
        if loop-player has permission "ec.host.panel":
            send "&2Also don't forget to type &e`/ec`&2 to check out new features!" to loop-player
            send "&3You are on the &e%{ec::config::channel}% &3channel." to loop-player
            if {ec::config::channel} is "BETA":
                send "&c&lWARNING: &cYou are using the BETA channel which may be unstable and very buggy!" to loop-player



command /createpoll:
    description: Start creating a poll (draft saved per-creator)
    permission: ec.host.poll.create
    trigger:
        if {poll::temp::%uuid of player%::state} is set:
            send "&cYou are already creating a poll. Type &ecancel&c to abort."
            stop
        set {poll::temp::%uuid of player%::state} to "question"
        delete {poll::temp::%uuid of player%::options::*}
        send "&2Poll creation started. Type the poll question now. Type &edone&2 to finish options or &ecancel&2 to abort at any time."


on chat:
    if {poll::temp::%uuid of player%::state} is "question":
        cancel event
        if message is "cancel":
            delete {poll::temp::%uuid of player%::*}
            send "&cPoll creation cancelled."
            stop
        set {poll::temp::%uuid of player%::question} to message
        set {poll::temp::%uuid of player%::state} to "option"
        send "&2Question saved. Type option #1 for the poll (minimum 2 required). Type &edone&2 when you've finished adding options, or &ecancel&2 to abort."

    else if {poll::temp::%uuid of player%::state} is "option":
        cancel event
        if message is "cancel":
            delete {poll::temp::%uuid of player%::*}
            send "&cPoll creation cancelled."
            stop
        if message is "done":
            set {_count} to size of {poll::temp::%uuid of player%::options::*}
            if {_count} < 2:
                send "&cYou need at least 2 options before finishing. Currently: &e%{_count}%&c."
                stop
            # finalize draft (move to draft namespace owned by creator)
            set {poll::draft::%uuid of player%::question} to {poll::temp::%uuid of player%::question}
            delete {poll::draft::%uuid of player%::options::*}
            loop {poll::temp::%uuid of player%::options::*}:
                add loop-value to {poll::draft::%uuid of player%::options::*}
            delete {poll::temp::%uuid of player%::*}
            send "&aDraft saved. Use &e/sendpoll&ato publish your draft when ready."
            stop
        # otherwise treat message as option text
        add message to {poll::temp::%uuid of player%::options::*}
        set {_i} to size of {poll::temp::%uuid of player%::options::*}
        send "&2Option &e%{_i}%&2 saved. Type next option, or &edone&2 if finished."

command /sendpoll [<text>]:
    description: Publish your draft poll (or publish <player>'s draft if you have permission)
    permission: ec.host.poll.send
    trigger:
        if {poll::active} is true:
            send "&cA poll is already active. End it first with /endpoll."
            stop

        if arg-1 is set:
            set {_target} to arg-1 parsed as string
            if offline player {_target} is set:
                set {_uuid} to uuid of offline player {_target}
            else:
                send "&cPlayer not found or no draft for that name."
                stop
            if {poll::draft::%{_uuid}%::question} isn't set:
                send "&cThat player has no saved draft."
                stop
        else:
            set {_uuid} to uuid of player
            if {poll::draft::%{_uuid}%::question} isn't set:
                send "&cYou have no saved draft. Use /createpoll to start one."
                stop

        set {poll::active} to true
        set {poll::active::creator} to {_uuid}
        set {poll::active::question} to {poll::draft::%{_uuid}%::question}
        delete {poll::active::options::*}
        loop {poll::draft::%{_uuid}%::options::*}:
            add loop-value to {poll::active::options::*}

        delete {poll::active::vote::*}
        delete {poll::active::tally::*}
        set {_i} to 0
        loop {poll::active::options::*}:
            add 1 to {_i}
            set {poll::active::tally::%{_i}%} to 0

        delete {poll::draft::%{_uuid}%::*}

        broadcast "&e--- New Poll ---"
        broadcast "&6Question: &r%{poll::active::question}%"
        set {_i} to 0
        loop {poll::active::options::*}:
            add 1 to {_i}
            broadcast formatted "&6%{_i}%. <run cmd:/pollvote %{_i}%>&e%loop-value%<reset>"
        broadcast "&2To vote: &e/pollvote <option_number>&2 (or click the option)."
        broadcast "&2Staff: end with &e/endpoll&2 when finished."

command /cancelpoll:
    description: Cancel your saved draft
    permission: ec.host.poll.cancel
    trigger:
        if {poll::draft::%uuid of player%::question} isn't set:
            send "&cYou have no draft to cancel."
            stop
        delete {poll::draft::%uuid of player%::*}
        send "&aYour draft has been cancelled."

command /pollvote <number>:
    description: Vote in the active poll
    usage: /pollvote <option_number>
    trigger:
        if {poll::active} is not true:
            send "&cThere is no active poll right now."
            stop
        set {_opt} to arg-1 parsed as integer
        if {_opt} is not set:
            send "&cInvalid option number."
            stop
        if {poll::active::options::%{_opt}%} is not set:
            send "&cThat option doesn't exist."
            stop
        if {poll::active::vote::%uuid of player%} is set:
            set {_prev} to {poll::active::vote::%uuid of player%}
            if {_prev} is {_opt}:
                send "&eYou already voted for option &6%{_opt}%&e."
                stop

            if {poll::active::tally::%{_prev}%} is set:
                remove 1 from {poll::active::tally::%{_prev}%}

        set {poll::active::vote::%uuid of player%} to {_opt}
        add 1 to {poll::active::tally::%{_opt}%}
        send "&aVote recorded: option &e%{_opt}%&a (%{poll::active::options::%{_opt}%}%)."

command /endpoll:
    description: End the active poll and show results
    permission: ec.host.poll.end
    aliases: /closepoll, /stoppoll, /finishpoll, /pollresults
    trigger:
        if {poll::active} is not true:
            send "&cThere is no active poll."
            stop

        broadcast "&e--- Poll Results ---"
        broadcast "&6Question: &r%{poll::active::question}%"
        set {_i} to 0
        loop {poll::active::options::*}:
            add 1 to {_i}
            set {_votes} to {poll::active::tally::%{_i}%}
            if {_votes} is not set:
                set {_votes} to 0
            broadcast formatted "&6%{_i}%. &e%loop-value% &2- &a%{_votes}% votes"

        delete {poll::active}
        delete {poll::active::*}

        broadcast "&2Poll ended."

command /currentpoll:
    description: View current active poll (brief)
    trigger:
        if {poll::active} is not true:
            send "&cNo active poll."
            stop
        send "&6Question: &r%{poll::active::question}%"
        set {_i} to 0
        loop {poll::active::options::*}:
            add 1 to {_i}
            set {_votes} to {poll::active::tally::%{_i}%}
            if {_votes} is not set:
                set {_votes} to 0
            send "&6%{_i}%. &e%loop-value% &2- &a%{_votes}%"

