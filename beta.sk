on join:
    wait 5 ticks
    if {server::name} isn't set:
        set {server::name} to "My cool server!"
    if {server::%uuid of player%::tokens} isn't set:
        set {server::%uuid of player%::tokens} to 0

    if {server::alive::*} contains player:
        remove player from {server::alive::*}
    if {server::dead::*} doesn't contain player:
        add player to {server::dead::*}
    if {server::spawn} is set:
        teleport player to {server::spawn}
    else:
        loop all players:
            if loop-player has permission "ec.setspawn":
                send "&cA player has joined but the spawn was not set and they were teleported to the worldspawn!"
                send "&cPlease set one using &e`/setspawn`"
    clear the player's inventory
    clear helmet of player
    clear chestplate of player
    clear leggings of player
    clear boots of player

# Main Host Panel
command /ec:
    executable by: players
    permission: ec.host.panel
    description: Open the EventCore host panel
    trigger:
        set {_panel} to a new chest inventory with 6 rows named "EventCore - Home"
        open {_panel} to player

on inventory click:
    if name of event-inventory is "EventCore - Home":
        cancel event


# Warps / TP
command /setwarp <text>:
    executable by: players
    description: Create a Warp
    permission: ec.host.warp.create
    usage: /setwarp <warp_name>
    aliases: createwarp, makewarp, addwarp
    trigger:
        set {_name} to arg-1
        set {_loc} to the player's location

        if {server::warps::%{_name}%} is set:
            send "&cThis warp already exists!" to player
            stop

        set {server::warps::%{_name}%} to {_name}
        set {server::warps::%{_name}%::loc} to {_loc}
        send "&2Created warp &e%{server::warps::%{_name}%}%&2 at location: &e%{server::warps::%{_name}%::loc}%"

command /delwarp <text>:
    description: Delete a Warp
    permission: ec.host.warp.delete
    usage: /delwarp <warp_name>
    aliases: deletewarp, unsetwarp, removewarp, remwarp
    trigger:
        set {_name} to arg-1

        if {server::warps::%{_name}%} isn't set:
            send "&cThis warp doesn't exist!" to player
            stop

        delete {server::warps::%{_name}%}
        send "&2Warp &e%{_name}%&2 Successfully deleted!"

command /tphere <text>:
    executable by: players
    description: Tp a player/all/dead/alive players to you
    permission: ec.host.tp.here
    usage: /tphere <player|all|dead|alive>
    trigger:
        set {_arg} to arg-1
        if {_arg} is "all":
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All players teleported to you!" to player
        else if {_arg} is "dead":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All dead players teleported to you!" to player
        else if {_arg} is "alive":
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All alive players teleported to you!" to player
        else:
            set {_arg} to {_arg} parsed as player
            if {_arg} isn't set:
                send "&cInvalid player/player is not online!" to player
            else:
                teleport {_arg} to player
                send "&e%{_arg}%&2 has been teleported to you!" to player
command /tpall [<text>]:
    executable by: players
    description: Teleported all players to you or a warp
    usage: /tpall [warp_name]
    permission: ec.host.tp.all
    trigger:
        set {_arg} to arg-1
        if {_arg} isn't set:
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All players teleported to you!" to player
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} isn't set:
                send "&cThis warp does not exist!" to player
                stop
            else:
                loop all players:
                    if {server::hosts::*} doesn't contain uuid of loop-value:
                        teleport loop-value to {_warp}
            send "&2All players teleported to &e!%{_warp}%!" to player

command /tpalive [<text>]:
    executable by: players
    description: Teleport all alive players to you or a warp
    permission: ec.host.tp.alive
    trigger:
        set {_arg} to arg-1
        if {_arg} is not set:
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player

            send "&2All alive players teleported to you!"
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} is not set:
                send "&cThis warp does not exist!"
                stop
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to {_warp}
            send "&2All alive players teleported to &e%{_arg}%!"

command /tpdead [<text>]:
    executable by: players
    description: Teleport all dead players to you or a warp
    permission: ec.host.tp.dead
    trigger:
        set {_arg} to arg-1
        if {_arg} is not set:
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to player
            send "&2All dead players teleported to you!"
        else:
            set {_warp} to {server::warps::%{_arg}%::loc}
            if {_warp} is not set:
                send "&cThis warp does not exist!"
                stop
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    teleport loop-value to {_warp}
            send "&2All dead players teleported to &e%{_arg}%!"

# Host management
command /addhost <player>:
    description: Set a player to be a host (does not give more permissions!)
    permission: ec.host.addhost
    aliases: createhost, makehost, sethost
    trigger:
        set {_arg} to arg-1
        if {server::hosts::*} contains uuid of {_arg}:
            send "&cThis player is already a host!"
            stop
        add uuid of {_arg} to {server::hosts::*} 
        send "&2Made &e%{_arg}%&2 a host!"

command /remhost <offline player>:
    description: Remove a player from the host list (does not remove permissions!)
    permission: ec.host.remhost
    aliases: removehost, deletehost, unsethost
    trigger:
        set {_arg} to arg-1
        if {server::hosts::*} doesn't contain uuid of {_arg}:
            send "&cThis player is not a host!"
            stop
        remove uuid of {_arg} from {server::hosts::*} 
        send "&2Remove &e%{_arg}%&2 from host list!"

# Server management
command /setserver <text>:
    description: Set the server name
    permission: ec.server.setserver
    usage: /setserver <name>
    trigger:
        set {_name} to arg-1
        set {server::name} to {_name}
        send "&2Set server name to &e%{server::name}%!"

command /setevent <text>:
    description: Set the next event
    permission: ec.server.event.setevent
    usage: /setevent <name>
    trigger:
        set {_name} to arg-1
        set {server::event} to {_name}
        send "&2Set event to &e%{server::event}%!"

command /setspawn:
    description: Set the server's spawnpoint
    permission: ec.setspawn
    trigger:
        set {server::spawn} to the player's position
        loop all players:
            if loop-value has permission "ec.setspawn":
                send "&e%player%&2 has set the spawnpoint to &e%{server::spawn}%"

# Timers and Cooldowns
command /timer [<text>]:
    description: Start or cancel a countdown timer
    permission: ec.host.timer
    usage: /timer (cancel|<seconds>)
    trigger:
        if arg-1 is "cancel":
            if {server::timer} > 0:
                set {server::timer} to 0
                send "&2Timer cancelled!"
            else:
                send "&cNo timer running!"
            stop

        set {_time} to arg-1 parsed as integer
        if {_time} <= 0:
            send "&cTime must be greater than 0!"
            stop
        if {server::timer} > 0:
            send "&cA timer is already running!"
            stop
        set {server::timer} to {_time}
        send "&2Timer started for %{_time}% seconds!"

        while {server::timer} > 0:
            broadcast "&e%{server::timer}% seconds left!"
            wait 1 second
            remove 1 from {server::timer}

        # This will always run after the timer reaches 0
        broadcast "&2Times up!"

command /eventcooldown <number>:
    description: Start the event cooldown
    permission: ec.host.event.cooldown
    usage: /eventcooldown <minutes>
    trigger:
        set {_arg} to arg-1
        if {_arg} <= 0:
            send "&cTime must be greater than 0!"
            stop
        if {server::event::cooldown} > 0:
            send "&cA cooldown is already running!"
            stop
        set {server::event::cooldown} to {_arg} * 60
        if {_arg} > 1:
            broadcast "&eEvent starts in &c%({server::event::cooldown} / 60)% &eminutes!"
        while {server::event::cooldown} > 0:
            if {server::event::cooldown} is 0:
                stop loop
            if {server::event::cooldown} >= 300:
                if mod({server::event::cooldown},300) = 0:
                    broadcast "&e%{server::event}% starts in &c%({server::event::cooldown} / 60)% &eminutes!"

            # 1 minute
            if {server::event::cooldown} = 60:
                broadcast "&e%{server::event}% starts in &c1 minute!"

            # 30 seconds
            if {server::event::cooldown} = 30:
                broadcast "&e%{server::event}% starts in &c30 seconds!"

            # 10 seconds
            if {server::event::cooldown} <= 10:
                broadcast "&e%{server::event}% starts in &c%{server::event::cooldown}% &eseconds!"

            wait 1 second
            remove 1 from {server::event::cooldown}
        broadcast "&a%{server::event}% is starting!!"


# Kits
command /createkit <text>:
    executable by: players
    description: Create a kit
    permission: ec.host.kits.create
    usage: /createkit <name>
    aliases: setkit, makekit, addkit
    trigger:
        set {_kit} to lowercase arg-1

        if {server::kits::%{_kit}%::exists} is true:
            send "&cThis kit already exists!"
            stop
        set {server::kits::%{_kit}%::exists} to true

        set {server::kits::%{_kit}%::armor::helmet} to player's helmet
        set {server::kits::%{_kit}%::armor::chestplate} to player's chestplate
        set {server::kits::%{_kit}%::armor::leggings} to player's leggings
        set {server::kits::%{_kit}%::armor::boots} to player's boots

        set {_slot} to 0 
        loop 36 times:
            set {server::kits::%{_kit}%::inv::%{_slot}%} to slot {_slot} of player's inventory
            add 1 to {_slot}

        send "&aCreated kit: &e%{_kit}%"

command /givekit <text> <text>:
    description: Give a kit to a player/group of players
    permission: ec.kits.givekit
    aliases: grantkit
    usage: /givekit <player|all|alive|dead> <kit>
    trigger:
        set {_arg} to arg-1
        set {_kit} to lowercase arg-2

        if {server::kits::%{_kit}%::exists} is not true:
            send "&cThis kit does not exist!"
            stop

        if {_arg} is "all":
            loop all players:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all players!"
            stop

        if {_arg} is "alive":
            loop {server::alive::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all alive players!"
            stop

        if {_arg} is "dead":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    giveKit(loop-value, {_kit})
            send "&2Gave kit &e%{_kit}%&2 to all dead players!"
            stop

        set {_p} to {_arg} parsed as player
        if {_p} is not set:
            send "&cInvalid player/player is not online!"
            stop

        giveKit({_p}, {_kit})
        send "&2Gave kit &e%{_kit}%&2 to &e%{_p}%!"

function giveKit(p: player, kit: text):
    clear {_p}'s inventory

    set {_p}'s helmet to {server::kits::%{_kit}%::armor::helmet}
    set {_p}'s chestplate to {server::kits::%{_kit}%::armor::chestplate}
    set {_p}'s leggings to {server::kits::%{_kit}%::armor::leggings}
    set {_p}'s boots to {server::kits::%{_kit}%::armor::boots}
    set {_slot} to 0
    loop 36 times:
        set slot {_slot} of {_p}'s inventory to {server::kits::%{_kit}%::inv::%{_slot}%}
        add 1 to {_slot}

command /deletekit <text>:
    executable by: players
    description: Delete a kit
    permission: ec.host.kits.delete
    usage: /deletekit <name>
    aliases: delkit, removekit
    trigger:
        set {_kit} to lowercase arg-1
        if {server::kits::%{_kit}%::exists} is not true:
            send "&cThis kit does not exist!"
            stop

        delete {server::kits::%{_kit}%}
        send "&2Deleted kit: &e%{_kit}%"

command /invsee <player>:
    executable by: players
    description: View/Edit a player's inventory
    permission: ec.invsee
    trigger:
        set {_player} to arg-1
        set {_inv} to {_player}'s inventory
        open {_inv} to player

command /stats [<player>]:
    description: View a player's stats
    trigger:
        set {_p} to arg-1
        if {_p} is not set: 
            set {_p} to player
        send "&eStats for %{_p}%:"
        send "&2Tokens: &e%{server::%uuid of {_p}%::tokens}%"
        send "&2Wins: &e%{server::%uuid of {_p}%::wins}%"
        send "&2Kills: &e%{server::%uuid of {_p}%::kills}%"
        send "&2Deaths: &e%{server::%uuid of {_p}%::deaths}%"


on death of player:
    set {server::deathTime::%uuid of victim%} to now
    force victim to respawn
    if attacker is a player:
        add 1 to {server::%uuid of attacker%::kills}
    add 1 to {server::%uuid of victim%::deaths}
    if {server::alive::*} contains victim:
        remove victim from {server::alive::*}
    if {server::dead::*} doesn't contain victim:
        add victim to {server::dead::*}

on respawn:
    if {server::spawn} is set:
        teleport player to {server::spawn}
    else:
        teleport player to spawn


# Gamemode
command /gmc [<player>]:
    description: Switch to creative mode
    permission: ec.host.gamemode.creative
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to creative
            stop
        set the player's gamemode to creative

command /gms [<player>]:
    description: Switch to survival mode
    permission: ec.host.gamemode.survival
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to survival
            stop
        set the player's gamemode to survival

command /gmsp [<player>]:
    description: Switch to spectator mode
    permission: ec.host.gamemode.spectator
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to spectator
            stop
        set the player's gamemode to spectator
    
command /gma [<player>]:
    description: Switch to adventure mode
    permission: ec.host.gamemode.adventure
    trigger:
        set {_p} to arg-1
        if {_p} is set:
            set {_p}'s gamemode to adventure
            stop
        set the player's gamemode to adventure

# Wins and Tokens
command /addwin <player>:
    description: Give a player a win
    permission: ec.host.wins.add
    aliases: givewin, grantwin
    trigger:
        set {_p} to arg-1

        add 1 to {server::%uuid of {_p}%::wins}
        broadcast "&e%{_p}%&2 has received a win! They now have &e%{server::%uuid of {_p}%::wins}% wins!"

command /addtoken <player>:
    description: Give a player a token
    permission: ec.host.tokens.add
    aliases: givetoken, granttoken, grantoken
    trigger:
        set {_p} to arg-1

        add 1 to {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&2 has received a revive token! They now have &e%{server::%uuid of {_p}%::tokens}% revive tokens!"

command /removewin <player>:
    description: Remove a win from a player
    permission: ec.host.wins.remove
    aliases: givewin, grantwin
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::wins} <= 0:
            send "&cThey don't have any wins!"
            stop
        remove 1 from {server::%uuid of {_p}%::wins}
        broadcast "&e%{_p}%&c has lost a win! They now have &e%{server::%uuid of {_p}%::wins}% wins!"

command /removetoken <player>:
    description: Remove a token from a player
    permission: ec.host.tokens.remove
    aliases: taketoken, remtoken, retractoken
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::tokens} <= 0:
            send "&cThey don't have any tokens!"
            stop
        remove 1 from {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&c has lost a revive token! They now have &e%{server::%uuid of {_p}%::tokens}% revive tokens!"

command /usetoken:
    description: Use a revive token
    cooldown: 1 minute
    cooldown message: You can request a revive in %remaining time%!
    trigger:
        if {server::%uuid of player%::requestingRevive} is true:
            send "&cYou are already requesting a revive!"
            stop
        if {server::%uuid of player%::tokens} < 1:
            send "&cYou don't have any tokens!"
            stop
        
        loop all players:
            if loop-value has permission "ec.host.tokens.accept":
                send "&e%player%&2 is requesting to use a revive token!"
                send "&e/accepttoken %player%&2 - Accept their token"
                send "&e/denytoken %player%&2 - Deny their token"
        set {server::%uuid of player%::requestingRevive} to true

command /accepttoken <player>:
    description: Accept a player's revive token
    permission: ec.host.tokens.accept
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::requestingRevive} isn't true:
            send "&cThis player isn't requesting a revive!"
            stop
        set {server::%uuid of {_p}%::requestingRevive} to false
        remove 1 from {server::%uuid of {_p}%::tokens}
        broadcast "&e%{_p}%&2 has used a revive token!"
        send "&2You accepted %{_p}%'s token!" to player
        send "&2You're token has been accepted!" to {_p}

command /denytoken <player>:
    description: Deny a player's revive token
    permission: ec.host.tokens.deny
    trigger:
        set {_p} to arg-1
        if {server::%uuid of {_p}%::requestingRevive} isn't true:
            send "&cThis player isn't requesting a revive!"
            stop
        set {server::%uuid of {_p}%::requestingRevive} to false
        send "&cYou denied %{_p}%'s token!" to player
        send "&cYou're token has been denied!" to {_p}

command /pvp:
    description: Toggle PvP in the current region
    permission: ec.host.worldguard.pvp
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {_reg} is not set:
            send "&cNo region detected."
            stop

        if {server::region::%{_reg}%::pvp} is true:
            set {server::region::%{_reg}%::pvp} to false
            make player execute command "region flag %{_reg}% -w %{_world}% pvp deny"
            broadcast "&câš” PvP disabled &7in region &e%{_reg}% &7(%{_world}%)"
        else:
            set {server::region::%{_reg}%::pvp} to true
            make player execute command "region flag %{_reg}% -w %{_world}% pvp allow"
            broadcast "&aâš” PvP enabled &7in region &e%{_reg}% &7(%{_world}%)"


# --- BLOCK BREAK ---
command /break:
    description: Toggle block breaking in the region
    permission: ec.host.worldguard.break
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::break} is true:
            set {server::region::%{_reg}%::break} to false
            make player execute command "region flag %{_reg}% -w %{_world}% block-break deny"
            broadcast "&cðŸ§± Block breaking disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::break} to true
            make player execute command "region flag %{_reg}% -w %{_world}% block-break allow"
            broadcast "&aðŸ§± Block breaking enabled &7in &e%{_reg}%"


# --- BLOCK PLACE ---
command /place:
    description: Toggle block placing in the region
    permission: ec.host.worldguard.place
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::place} is true:
            set {server::region::%{_reg}%::place} to false
            make player execute command "region flag %{_reg}% -w %{_world}% block-place deny"
            broadcast "&cðŸ“¦ Block placing disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::place} to true
            make player execute command "region flag %{_reg}% -w %{_world}% block-place allow"
            broadcast "&aðŸ“¦ Block placing enabled &7in &e%{_reg}%"


# --- WATER FLOW ---
command /flow:
    description: Toggle water & lava flow in the region
    permission: ec.host.worldguard.flow
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {server::region::%{_reg}%::flow} is true:
            set {server::region::%{_reg}%::flow} to false
            make player execute command "region flag %{_reg}% -w %{_world}% water-flow deny"
            make player execute command "region flag %{_reg}% -w %{_world}% lava-flow deny"
            broadcast "&cðŸŒŠ Fluid flow disabled &7in &e%{_reg}%"
        else:
            set {server::region::%{_reg}%::flow} to true
            make player execute command "region flag %{_reg}% -w %{_world}% water-flow allow"
            make player execute command "region flag %{_reg}% -w %{_world}% lava-flow allow"
            broadcast "&aðŸŒŠ Fluid flow enabled &7in &e%{_reg}%"

# --- FALL DAMAGE ---
command /fall:
    description: Toggle fall damage in the region
    permission: ec.host.worldguard.fall
    trigger:
        if plugin "WorldGuard" isn't enabled:
            send "&cWorldGuard is not installed!"
            stop

        set {_reg} to {server::%uuid of player%::region}
        set {_world} to {server::%uuid of player%::world}

        if {_reg} is not set:
            send "&cNo region detected."
            stop

        if {server::region::%{_reg}%::fall} is true:
            set {server::region::%{_reg}%::fall} to false
            make player execute command "region flag %{_reg}% -w %{_world}% fall-damage deny"
            broadcast "&cðŸª‚ Fall damage disabled &7in region &e%{_reg}% &7(%{_world}%)"
        else:
            set {server::region::%{_reg}%::fall} to true
            make player execute command "region flag %{_reg}% -w %{_world}% fall-damage allow"
            broadcast "&aðŸª‚ Fall damage enabled &7in region &e%{_reg}% &7(%{_world}%)"

# Scoreboard
on join:
    if {server::hosts::*} doesn't contain player:
        set {_board} to player's scoreboard
        set line 1 of {_board} to "Event:"
        set score of line 1 of {_board} to {server::event}

        set line 2 of {_board} to "Wins:"
        set score of line 2 of {_board} to "&e%{server::%uuid of player%::wins}%"

        set line 3 of {_board} to "Tokens:"
        set score of line 3 of {_board} to "&e%{server::%uuid of player%::tokens}%"
        set player's scoreboard to {_board}
        set title of player's scoreboard to "&cDeath &eEvents"
    else:
        set {_board} to player's scoreboard
        set line 1 of {_board} to "Event:"
        set score of line 1 of {_board} to {server::event}

        set line 2 of {_board} to "Alive:"
        set score of line 2 of {_board} to "&e%size of {server::alive::*}%"

        set line 3 of {_board} to "Dead:"
        set score of line 3 of {_board} to "&e%size of {server::dead::*}%"

        set line 4 of {_board} to "Total:"
        set score of line 4 of {_board} to "&e%size of all players%"

        set player's scoreboard to {_board}
        set title of player's scoreboard to "&cDeath &eEvents &7- Host"

every second:
    loop all players:
        if {server::hosts::*} doesn't contain loop-player:
            set {_board} to loop-player's scoreboard
            set line 1 of {_board} to "Event:"
            set score of line 1 of {_board} to {server::event}

            set line 2 of {_board} to "Wins:"
            set score of line 2 of {_board} to "&e%{server::%uuid of loop-player%::wins}%"

            set line 3 of {_board} to "Tokens:"
            set score of line 3 of {_board} to "&e%{server::%uuid of loop-player%::tokens}%"
            set loop-player's scoreboard to {_board}
            set title of loop-player's scoreboard to "&cDeath &eEvents"
        else:
            set {_board} to loop-player's scoreboard
            set line 1 of {_board} to "Event:"
            set score of line 1 of {_board} to {server::event}

            set line 2 of {_board} to "Alive:"
            set score of line 2 of {_board} to "&e%size of {server::alive::*}%"

            set line 3 of {_board} to "Dead:"
            set score of line 3 of {_board} to "&e%size of {server::dead::*}%"

            set line 4 of {_board} to "Total:"
            set score of line 4 of {_board} to "&e%size of all players%"

            set loop-player's scoreboard to {_board}
            set title of loop-player's scoreboard to "&cDeath &eEvents &7- Host"


on enter of region:
    set {_rg} to "%region%"
    set {_regions::*} to split {_rg} at " "
    set {_region} to {_regions::1}
    set {server::%uuid of player%::region} to {_region}
    set {server::%uuid of player%::world} to name of player's world

command /whereami:
    permission: ec.whereami
    trigger:
        send "&aRegion: &e%{server::%uuid of player%::region}%"
        send "&aWorld: &e%{server::%uuid of player%::world}%"




# Revives
function revivePlayer(p: player, user: player):
    if {server::dead::*} contains {_p}:
        remove {_p} from {server::dead::*}
    if {server::alive::*} doesn't contain {_p}:
        add {_p} to {server::alive::*}

    clear {_p}'s inventory
    set {_p}'s gamemode to survival
    teleport {_p} to {_user}

    send "&aâ˜  You have been revived!" to {_p}

command /revive <text> [<number>]:
    description: Revive players
    permission: ec.host.revive
    usage: /revive (all|last|<player>) [seconds]
    aliases: rev, res
    trigger:
        set {_arg} to arg-1

        # --- REVIVE ALL ---
        if {_arg} is "all":
            loop {server::dead::*}:
                if {server::hosts::*} doesn't contain uuid of loop-value:
                    revivePlayer(loop-value, player)
            broadcast "&aâœ¨ All players have been revived!"
            stop

        # --- REVIVE LAST ---
        if {_arg} is "last":
            set {_secs} to arg-2 parsed as number
            if {_secs} is not set or {_secs} <= 0:
                send "&cYou must specify seconds. &7(/revive last <seconds>)"
                stop

            set {_count} to 0
            loop {server::dead::*}:
                set {_t} to {server::deathTime::%uuid of loop-value%}
                if {_t} is set:
                    if difference between {_t} and now <= {_secs} seconds:
                        revivePlayer(loop-value, player)
                        add 1 to {_count}

            if {_count} > 0:
                broadcast "&aâœ¨ Revived %{_count}% player(s) who died in the last %{_secs}%s!"
            else:
                send "&cNo players died in the last %{_secs}% seconds."
            stop

        # --- REVIVE PLAYER ---
        set {_p} to {_arg} parsed as player
        if {_p} is not set:
            send "&cInvalid player!"
            stop

        if {server::dead::*} doesn't contain {_p}:
            send "&cThat player is not dead!"
            stop

        revivePlayer({_p}, player)
        broadcast "&aâœ¨ %{_p}% has been revived!"

# Mute chat
command /mutechat:
    description: Mute the chat so only hosts can talk
    permission: ec.host.chat.mute
    trigger:
        if {server::chat::muted} is true:
            send "&cChat is already muted!" to player
            stop
        set {server::chat::muted} to true
        broadcast "&cChat has been muted! Only hosts can talk now."

# Unmute chat
command /unmutechat:
    description: Unmute the chat
    permission: ec.host.chat.mute
    trigger:
        if {server::chat::muted} is false:
            send "&cChat is not muted!" to player
            stop
        set {server::chat::muted} to false
        broadcast "&aChat has been unmuted! Everyone can talk now."

# Block messages from non-hosts when chat is muted
on chat:
    if {server::chat::muted} is true:
        if {server::hosts::*} does not contain uuid of player:
            cancel event
            send "&cChat is currently muted! Only hosts can speak."
